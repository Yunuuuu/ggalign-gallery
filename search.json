[
  {
    "objectID": "basics/plot-composer-inset.html",
    "href": "basics/plot-composer-inset.html",
    "title": "Plot Composer - Inset",
    "section": "",
    "text": "Plot Composer - Inset\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\nlibrary(grid)\n# Create the main scatter plot: mpg vs disp\np1 &lt;- ggplot(mtcars) +\n    geom_point(aes(mpg, disp))\n\n# Create the inset plot: boxplot of disp by gear\np2 &lt;- ggplot(mtcars) +\n    geom_boxplot(aes(gear, disp, group = gear))\n\n# Compose the plots: insert p2 into p1 using a viewport\np1 + inset(p2, vp = viewport(0.6, 0.6,\n    just = c(0, 0), width = 0.4, height = 0.4\n))"
  },
  {
    "objectID": "basics/complexheatmap.html",
    "href": "basics/complexheatmap.html",
    "title": "ComplexHeatmap Reproduction",
    "section": "",
    "text": "In this thread, we use ggalign to recreate all the heatmaps shown inhttps://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\nset.seed(123)\nnr1 &lt;- 4\nnr2 &lt;- 8\nnr3 &lt;- 6\nnr &lt;- nr1 + nr2 + nr3\nnc1 &lt;- 6\nnc2 &lt;- 8\nnc3 &lt;- 10\nnc &lt;- nc1 + nc2 + nc3\nmat &lt;- cbind(\n    rbind(\n        matrix(rnorm(nr1 * nc1, mean = 1, sd = 0.5), nrow = nr1),\n        matrix(rnorm(nr2 * nc1, mean = 0, sd = 0.5), nrow = nr2),\n        matrix(rnorm(nr3 * nc1, mean = 0, sd = 0.5), nrow = nr3)\n    ),\n    rbind(\n        matrix(rnorm(nr1 * nc2, mean = 0, sd = 0.5), nrow = nr1),\n        matrix(rnorm(nr2 * nc2, mean = 1, sd = 0.5), nrow = nr2),\n        matrix(rnorm(nr3 * nc2, mean = 0, sd = 0.5), nrow = nr3)\n    ),\n    rbind(\n        matrix(rnorm(nr1 * nc3, mean = 0.5, sd = 0.5), nrow = nr1),\n        matrix(rnorm(nr2 * nc3, mean = 0.5, sd = 0.5), nrow = nr2),\n        matrix(rnorm(nr3 * nc3, mean = 1, sd = 0.5), nrow = nr3)\n    )\n)\nmat &lt;- mat[sample(nr, nr), sample(nc, nc)]\nrownames(mat) &lt;- paste0(\"row\", seq_len(nr))\ncolnames(mat) &lt;- paste0(\"column\", seq_len(nc))\n\n\nIt is important to note that the ComplexHeatmap package reorders the dendrogram by default, while align_dendro() in ggalign does not modify the tree layout.\nAnother key difference is in how the two packages treat the starting point. ggalign considers the left-bottom as the starting point, whereas ComplexHeatmap starts from the left-top. When reordering the dendrogram, ComplexHeatmap does so in decreasing order, while ggalign uses an ascending order.\nTo modify colors in the heatmap, you can use the scale_fill_*() function from ggplot2, which provides a flexible way and enriched pallete to adjust color schemes.\n\ndim(mat)\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n# ComplexHeatmap::Heatmap(mat)\n#&gt; [1] 18 24\n\n\nggheatmap(mat) +\n    scale_fill_gradient2(low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro() +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\noob argument in the scale_fill_* function can be used to deal with the outliers.\n\nmat2 &lt;- mat\nmat2[1, 1] &lt;- 100000\nggheatmap(mat2) +\n    scale_fill_gradient2(\n        low = \"green\", high = \"red\",\n        limits = c(-2, 2),\n        oob = scales::squish\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nWe can use align_plots() to arrange them.\n\nh1 &lt;- ggheatmap(mat) +\n    scale_fill_gradient2(name = \"mat\", low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n\nh2 &lt;- ggheatmap(mat / 4) +\n    scale_fill_gradient2(\n        name = \"mat/4\", limits = c(-2, 2L),\n        oob = scales::squish,\n        low = \"green\", high = \"red\"\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n\nh3 &lt;- ggheatmap(abs(mat)) +\n    scale_fill_gradient2(name = \"abs(mat)\", low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\nalign_plots(h1, h2, h3, ncol = 2L)\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    scale_fill_gradientn(colors = rev(rainbow(10))) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nFor character matrix, you can use ggplot2 discrete filling scales.\n\ndiscrete_mat &lt;- matrix(sample(1:4, 100, replace = TRUE), 10, 10)\ncolors &lt;- structure(1:4, names = c(\"1\", \"2\", \"3\", \"4\")) # black, red, green, blue\nggheatmap(discrete_mat, aes(fill = factor(value))) +\n    scale_fill_manual(values = colors) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\ndiscrete_mat &lt;- matrix(sample(letters[1:4], 100, replace = TRUE), 10, 10)\ncolors &lt;- structure(1:4, names = letters[1:4])\nggheatmap(discrete_mat) +\n    scale_fill_manual(values = colors)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nmat_with_na &lt;- mat\nna_index &lt;- sample(c(TRUE, FALSE),\n    nrow(mat) * ncol(mat),\n    replace = TRUE, prob = c(1, 9)\n)\nmat_with_na[na_index] &lt;- NA\nggheatmap(mat_with_na) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", na.value = \"black\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nWe won’t compare the LAB and RGB space. If you want to convert color between different color space, try to use farver pacakge.\nIn ggplot2, you can use panel.border argument in theme() function to control the Heatmap body border.\n\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        panel.border = element_rect(linetype = \"dashed\", fill = NA)\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can use the filling argument to turn off the heatmap cell filling, allowing you to customize the heatmap body geoms. Use the color aesthetic to specify the cell border color and the linewidth aesthetic to set the border width.\n\nggheatmap(mat, filling = NULL) +\n    geom_tile(aes(fill = value), color = \"white\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\n\n\n\n\n\n\n\nTo draw a blank heatmap body:\n\nggheatmap(mat, filling = NULL) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\n\n\n\n\n\n\n\n\nWe can use patch_titles() to add titles around each border of the plot. You can use theme() to control the text appearance.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(right = \"I am a row title\") +\n    theme(plot.patch_title.right = element_text(face = \"bold\", size = 16)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"I am a column title\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n# ComplexHeatmap::Heatmap(mat,\n#   name = \"mat\", clustering_distance_rows = \"pearson\",\n#   column_title = \"pre-defined distance method (1 - pearson)\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(distance = \"pearson\", reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"pre-defined distance method (1 - pearson)\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\", clustering_distance_rows = function(m) dist(m),\n#     column_title = \"a function that calculates distance matrix\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(distance = dist, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"a function that calculates distance matrix\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nMethod to perform hierarchical clustering can be specified by method argument, Possible methods are those supported in hclust() function.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\",\n#     clustering_method_rows = \"single\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(method = \"single\", reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nUse distance = NULL if you don’t want to calculate the distance.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(\n        distance = NULL, method = cluster::diana,\n        reorder_dendrogram = TRUE\n    ) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(\n        distance = NULL, method = cluster::agnes,\n        reorder_dendrogram = TRUE\n    ) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIt’s easy for ggalign to color the branches by setting the color mapping, since ggalign will add the cutree() results into the underlying data.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(aes(color = branch), k = 2L, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nWe can use align_order() to set the order.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\",\n#     row_order = order(as.numeric(gsub(\"row\", \"\", rownames(mat)))),\n#     column_order = order(as.numeric(gsub(\"column\", \"\", colnames(mat)))),\n#     column_title = \"reorder matrix\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_order(as.numeric(gsub(\"row\", \"\", rownames(mat)))) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_order(as.numeric(gsub(\"column\", \"\", colnames(mat)))) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nalign_order2() can directly take the seriate() function as the input and extract the ordering information.\n\nmat2 &lt;- max(mat) - mat\nggheatmap(mat2) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", midpoint = 2L) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_order2(seriation::seriate, method = \"BEA_TSP\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_order2(seriation::seriate, method = \"BEA_TSP\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nThe above code will execute seriate() twice—once for each dimension. However, since a single run of seriate() can provide the ordering for both dimensions, we can manually extract the ordering indices to avoid redundancy.\n\no &lt;- seriation::seriate(mat2, method = \"BEA_TSP\")\nggheatmap(mat2) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", midpoint = 2L) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_order(seriation::get_order(o, 1L)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_order(seriation::get_order(o, 2L)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nFor more use of the seriate() function, please refer to the seriation package.\n\nggplot2 use scales and theme to control the axis labels, Please see chapter for more details.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\", row_names_side = \"left\", row_dend_side = \"right\",\n#     column_names_side = \"top\", column_dend_side = \"bottom\"\n# )\nggheatmap(mat) +\n    scale_x_continuous(position = \"top\") +\n    scale_y_continuous(position = \"right\") +\n    theme(axis.text.x = element_text(angle = 60, hjust = 0)) +\n    anno_left(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    scale_x_continuous(position = \"top\") +\n    anno_bottom(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    scale_y_continuous(position = \"right\") +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    scale_y_continuous(breaks = NULL) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        axis.text.y = element_text(face = \"bold\", size = 16)\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        axis.text.y = element_text(\n            face = \"bold\", size = 16,\n            colour = c(rep(\"red\", 10), rep(\"blue\", 8))\n        )\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; Warning: Vectorized input to `element_text()` is not officially supported.\n#&gt; ℹ Results may be unexpected or may change in future versions of ggplot2.\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_kmeans(2L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_kmeans(3L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_kmeans(2L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_kmeans(3L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nThe dendrogram was calculated in each group defined by kmeans.\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(c(\"A\", \"B\"), 9)) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(c(\"C\", \"D\"), 12)) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nWhen you splitted by a dendrogram, the cutted height will be indicated with a dashed line.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(k = 3L, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(k = 2L, reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(aes(color = branch), k = 3L, reorder_dendrogram = TRUE) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(k = 2L, reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe order of the panels always follow the factor level. Note: the merging of dendrogram between ComplexHeatmap and ggalign is a little different.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(LETTERS[1:3], 6)) +\n    align_dendro(aes(color = branch),\n        reorder_dendrogram = TRUE,\n        reorder_group = TRUE,\n        merge_dendrogram = TRUE\n    ) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(letters[1:6], 4)) +\n    align_dendro(aes(color = branch),\n        reorder_dendrogram = TRUE,\n        reorder_group = TRUE,\n        merge_dendrogram = TRUE\n    ) +\n    quad_active() -\n    quad_scope(theme(strip.text = element_text()), \"tr\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(LETTERS[1:3], 6)) +\n    align_dendro(aes(color = branch), reorder_dendrogram = TRUE) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(letters[1:6], 4)) +\n    align_dendro(aes(color = branch), reorder_dendrogram = TRUE) +\n    quad_active() -\n    quad_scope(theme(strip.text = element_text()), \"tr\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/complexheatmap.html#colors",
    "href": "basics/complexheatmap.html#colors",
    "title": "ComplexHeatmap Reproduction",
    "section": "",
    "text": "It is important to note that the ComplexHeatmap package reorders the dendrogram by default, while align_dendro() in ggalign does not modify the tree layout.\nAnother key difference is in how the two packages treat the starting point. ggalign considers the left-bottom as the starting point, whereas ComplexHeatmap starts from the left-top. When reordering the dendrogram, ComplexHeatmap does so in decreasing order, while ggalign uses an ascending order.\nTo modify colors in the heatmap, you can use the scale_fill_*() function from ggplot2, which provides a flexible way and enriched pallete to adjust color schemes.\n\ndim(mat)\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n# ComplexHeatmap::Heatmap(mat)\n#&gt; [1] 18 24\n\n\nggheatmap(mat) +\n    scale_fill_gradient2(low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro() +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\noob argument in the scale_fill_* function can be used to deal with the outliers.\n\nmat2 &lt;- mat\nmat2[1, 1] &lt;- 100000\nggheatmap(mat2) +\n    scale_fill_gradient2(\n        low = \"green\", high = \"red\",\n        limits = c(-2, 2),\n        oob = scales::squish\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nWe can use align_plots() to arrange them.\n\nh1 &lt;- ggheatmap(mat) +\n    scale_fill_gradient2(name = \"mat\", low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n\nh2 &lt;- ggheatmap(mat / 4) +\n    scale_fill_gradient2(\n        name = \"mat/4\", limits = c(-2, 2L),\n        oob = scales::squish,\n        low = \"green\", high = \"red\"\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n\nh3 &lt;- ggheatmap(abs(mat)) +\n    scale_fill_gradient2(name = \"abs(mat)\", low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\nalign_plots(h1, h2, h3, ncol = 2L)\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    scale_fill_gradientn(colors = rev(rainbow(10))) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nFor character matrix, you can use ggplot2 discrete filling scales.\n\ndiscrete_mat &lt;- matrix(sample(1:4, 100, replace = TRUE), 10, 10)\ncolors &lt;- structure(1:4, names = c(\"1\", \"2\", \"3\", \"4\")) # black, red, green, blue\nggheatmap(discrete_mat, aes(fill = factor(value))) +\n    scale_fill_manual(values = colors) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\ndiscrete_mat &lt;- matrix(sample(letters[1:4], 100, replace = TRUE), 10, 10)\ncolors &lt;- structure(1:4, names = letters[1:4])\nggheatmap(discrete_mat) +\n    scale_fill_manual(values = colors)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nmat_with_na &lt;- mat\nna_index &lt;- sample(c(TRUE, FALSE),\n    nrow(mat) * ncol(mat),\n    replace = TRUE, prob = c(1, 9)\n)\nmat_with_na[na_index] &lt;- NA\nggheatmap(mat_with_na) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", na.value = \"black\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nWe won’t compare the LAB and RGB space. If you want to convert color between different color space, try to use farver pacakge.\nIn ggplot2, you can use panel.border argument in theme() function to control the Heatmap body border.\n\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        panel.border = element_rect(linetype = \"dashed\", fill = NA)\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can use the filling argument to turn off the heatmap cell filling, allowing you to customize the heatmap body geoms. Use the color aesthetic to specify the cell border color and the linewidth aesthetic to set the border width.\n\nggheatmap(mat, filling = NULL) +\n    geom_tile(aes(fill = value), color = \"white\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\n\n\n\n\n\n\n\nTo draw a blank heatmap body:\n\nggheatmap(mat, filling = NULL) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())"
  },
  {
    "objectID": "basics/complexheatmap.html#titles",
    "href": "basics/complexheatmap.html#titles",
    "title": "ComplexHeatmap Reproduction",
    "section": "",
    "text": "We can use patch_titles() to add titles around each border of the plot. You can use theme() to control the text appearance.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(right = \"I am a row title\") +\n    theme(plot.patch_title.right = element_text(face = \"bold\", size = 16)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"I am a column title\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/complexheatmap.html#clustering",
    "href": "basics/complexheatmap.html#clustering",
    "title": "ComplexHeatmap Reproduction",
    "section": "",
    "text": "# ComplexHeatmap::Heatmap(mat,\n#   name = \"mat\", clustering_distance_rows = \"pearson\",\n#   column_title = \"pre-defined distance method (1 - pearson)\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(distance = \"pearson\", reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"pre-defined distance method (1 - pearson)\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\", clustering_distance_rows = function(m) dist(m),\n#     column_title = \"a function that calculates distance matrix\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(distance = dist, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"a function that calculates distance matrix\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nMethod to perform hierarchical clustering can be specified by method argument, Possible methods are those supported in hclust() function.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\",\n#     clustering_method_rows = \"single\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(method = \"single\", reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nUse distance = NULL if you don’t want to calculate the distance.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(\n        distance = NULL, method = cluster::diana,\n        reorder_dendrogram = TRUE\n    ) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(\n        distance = NULL, method = cluster::agnes,\n        reorder_dendrogram = TRUE\n    ) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIt’s easy for ggalign to color the branches by setting the color mapping, since ggalign will add the cutree() results into the underlying data.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(aes(color = branch), k = 2L, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/complexheatmap.html#set-row-and-column-orders",
    "href": "basics/complexheatmap.html#set-row-and-column-orders",
    "title": "ComplexHeatmap Reproduction",
    "section": "",
    "text": "We can use align_order() to set the order.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\",\n#     row_order = order(as.numeric(gsub(\"row\", \"\", rownames(mat)))),\n#     column_order = order(as.numeric(gsub(\"column\", \"\", colnames(mat)))),\n#     column_title = \"reorder matrix\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_order(as.numeric(gsub(\"row\", \"\", rownames(mat)))) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_order(as.numeric(gsub(\"column\", \"\", colnames(mat)))) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/complexheatmap.html#seriation",
    "href": "basics/complexheatmap.html#seriation",
    "title": "ComplexHeatmap Reproduction",
    "section": "",
    "text": "align_order2() can directly take the seriate() function as the input and extract the ordering information.\n\nmat2 &lt;- max(mat) - mat\nggheatmap(mat2) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", midpoint = 2L) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_order2(seriation::seriate, method = \"BEA_TSP\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_order2(seriation::seriate, method = \"BEA_TSP\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nThe above code will execute seriate() twice—once for each dimension. However, since a single run of seriate() can provide the ordering for both dimensions, we can manually extract the ordering indices to avoid redundancy.\n\no &lt;- seriation::seriate(mat2, method = \"BEA_TSP\")\nggheatmap(mat2) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", midpoint = 2L) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_order(seriation::get_order(o, 1L)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_order(seriation::get_order(o, 2L)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nFor more use of the seriate() function, please refer to the seriation package."
  },
  {
    "objectID": "basics/complexheatmap.html#dimension-labels",
    "href": "basics/complexheatmap.html#dimension-labels",
    "title": "ComplexHeatmap Reproduction",
    "section": "",
    "text": "ggplot2 use scales and theme to control the axis labels, Please see chapter for more details.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\", row_names_side = \"left\", row_dend_side = \"right\",\n#     column_names_side = \"top\", column_dend_side = \"bottom\"\n# )\nggheatmap(mat) +\n    scale_x_continuous(position = \"top\") +\n    scale_y_continuous(position = \"right\") +\n    theme(axis.text.x = element_text(angle = 60, hjust = 0)) +\n    anno_left(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    scale_x_continuous(position = \"top\") +\n    anno_bottom(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    scale_y_continuous(position = \"right\") +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    scale_y_continuous(breaks = NULL) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        axis.text.y = element_text(face = \"bold\", size = 16)\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        axis.text.y = element_text(\n            face = \"bold\", size = 16,\n            colour = c(rep(\"red\", 10), rep(\"blue\", 8))\n        )\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; Warning: Vectorized input to `element_text()` is not officially supported.\n#&gt; ℹ Results may be unexpected or may change in future versions of ggplot2.\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/complexheatmap.html#heatmap-split",
    "href": "basics/complexheatmap.html#heatmap-split",
    "title": "ComplexHeatmap Reproduction",
    "section": "",
    "text": "ggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_kmeans(2L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_kmeans(3L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_kmeans(2L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_kmeans(3L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nThe dendrogram was calculated in each group defined by kmeans.\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(c(\"A\", \"B\"), 9)) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(c(\"C\", \"D\"), 12)) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nWhen you splitted by a dendrogram, the cutted height will be indicated with a dashed line.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(k = 3L, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(k = 2L, reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(aes(color = branch), k = 3L, reorder_dendrogram = TRUE) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(k = 2L, reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe order of the panels always follow the factor level. Note: the merging of dendrogram between ComplexHeatmap and ggalign is a little different.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(LETTERS[1:3], 6)) +\n    align_dendro(aes(color = branch),\n        reorder_dendrogram = TRUE,\n        reorder_group = TRUE,\n        merge_dendrogram = TRUE\n    ) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(letters[1:6], 4)) +\n    align_dendro(aes(color = branch),\n        reorder_dendrogram = TRUE,\n        reorder_group = TRUE,\n        merge_dendrogram = TRUE\n    ) +\n    quad_active() -\n    quad_scope(theme(strip.text = element_text()), \"tr\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(LETTERS[1:3], 6)) +\n    align_dendro(aes(color = branch), reorder_dendrogram = TRUE) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(letters[1:6], 4)) +\n    align_dendro(aes(color = branch), reorder_dendrogram = TRUE) +\n    quad_active() -\n    quad_scope(theme(strip.text = element_text()), \"tr\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/plot-composer-wrap.html",
    "href": "basics/plot-composer-wrap.html",
    "title": "Plot Composer – Arbitrary Plots",
    "section": "",
    "text": "Plot Composer – Arbitrary Plots\nThe ggalign package includes the ggwrap() function, which enables the conversion of non-ggplot2 elements into a general object that is compatible with align_plots(). This provides a versatile tool for incorporating any type of graphics within R.\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\np1 &lt;- ggplot(mtcars) +\n    geom_point(aes(mpg, disp)) +\n    ggtitle(\"Plot 1\")\n\nAdd base plot:\n\nalign_plots(p1, ggwrap(~ plot(mtcars$mpg, mtcars$disp)))\n\n\n\n\n\n\n\n\nbase plot should be provided using formula.\n\n\nalign_plots(\n    p1,\n    ggwrap(\n        ~ plot(mtcars$mpg, mtcars$disp),\n        align = \"full\"\n    )\n)\n\n\n\n\n\n\n\n\nalign_plots(\n    p1,\n    ggwrap(~ plot(mtcars$mpg, mtcars$disp)) +\n        # add title for new plot\n        ggtitle(\"Plot 2\")\n)\n\n\n\n\n\n\n\nSet plot widths:\n\nalign_plots(\n    p1,\n    ggwrap(~ plot(mtcars$mpg, mtcars$disp)),\n    widths = c(1, 2)\n)\n\n\n\n\n\n\n\nSince ggwrap() is automatically called in most cases, you can write code like:\n\nalign_plots(\n    p1,\n    ~ plot(mtcars$mpg, mtcars$disp)\n)\n\n\n\n\n\n\n\nAdd grid grobs, for example:\n\nalign_plots(\n    p1,\n    grid::textGrob(\"Some really important text\")\n)\n\n\n\n\n\n\n\nAdd cluster plot:\n\nhc &lt;- hclust(dist(USArrests), \"ave\")\nalign_plots(p1, ~ plot(hc))\n\n\n\n\n\n\n\nAdd lattice plots:\n\nalign_plots(\n    p1,\n    lattice::xyplot(disp ~ mpg, data = mtcars)\n)\n\n\n\n\n\n\n\nAdd pheatmap:\n\nalign_plots(\n    p1,\n    pheatmap::pheatmap(matrix(rnorm(200), 20, 10), silent = TRUE)\n)\n\n\n\n\n\n\n\nAdd ComplexHeatmap:\n\nalign_plots(\n    p1,\n    ComplexHeatmap::pheatmap(matrix(rnorm(200), 20, 10))\n)"
  },
  {
    "objectID": "basics/geom-magick.html",
    "href": "basics/geom-magick.html",
    "title": "Using images as points in ggplot2",
    "section": "",
    "text": "Using images as points in ggplot2\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\ngeom_magick() Reads an image with magick, applies optional processing, and uses the result as the graphical shape for points in a plot.\nThis is useful when you want to replace the usual point symbols with arbitrary images while keeping full control over their placement, size, and interpolation.\n\nset.seed(123)\nd &lt;- data.frame(\n    x = rnorm(10),\n    y = rnorm(10),\n    image = \"https://jeroenooms.github.io/images/frink.png\",\n    fill = sample(c(\"A\", \"B\", \"C\", \"D\"), 10, replace = TRUE),\n    alpha = rnorm(10, mean = 0.5, sd = 0.1)\n)\nd$alpha &lt;- pmax(pmin(d$alpha, 1), 0)\n\nYou can combine the image with a fill color and transparency mapping. The fill is applied on top of the image, allowing for color-coded categories without losing the image shape. The size aesthetic controls the image width in \"mm\".\n\nggplot(d, aes(x, y)) +\n    geom_magick(\n        aes(image = image, fill = fill, alpha = alpha),\n        size = 12, show.legend = FALSE\n    ) + \n    coord_cartesian(clip = \"off\")"
  },
  {
    "objectID": "basics/plot-composer-tagging.html",
    "href": "basics/plot-composer-tagging.html",
    "title": "Plot Composer – tagging",
    "section": "",
    "text": "When multiple plots are combined into a single figure—common in scientific publications—they are often referenced by tags or labels (e.g., “A”, “B”, “C”). While these tags can be added manually, it is much easier to let ggalign handle tagging automatically using the layout_tags() function.\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\np1 &lt;- ggplot(mtcars) +\n    geom_point(aes(mpg, disp))\np2 &lt;- ggplot(mtcars) +\n    geom_boxplot(aes(factor(gear), disp))\np3 &lt;- ggplot(mtcars) +\n    geom_bar(aes(factor(gear))) +\n    facet_wrap(~cyl)\n\n\nSet the tags argument in layout_tags() to specify the family of symbols used for tagging plots:\n\n\n\"1\": Arabic numerals (1, 2, 3, …)\n\n\"A\": Uppercase Latin letters (A, B, C, …)\n\n\"a\": Lowercase Latin letters (a, b, c, …)\n\n\"I\": Uppercase Roman numerals (I, II, III, …)\n\n\"i\": Lowercase Roman numerals (i, ii, iii, …)\n\nBy default, nested layouts receive their own tags:\n\nalign_plots(p1, align_plots(p2, p3), ncol = 1) + layout_tags(\"A\")\n\n\n\n\n\n\n\n\nTo treat a nested layout as a single plot with a single tag, disable its internal tags by setting tags = NULL:\n\nalign_plots(p1, align_plots(p2, p3) + layout_tags(NULL), ncol = 1) +\n    layout_tags(\"A\")\n\n\n\n\n\n\n\n\nApply multilevel tagging where the outer layout uses letters and the inner layout uses numbers. You can specify a separator between parent and child tags:\n\nalign_plots(\n    p1,\n    align_plots(p2, p3) + layout_tags(1, sep = \": \"),\n    ncol = 1\n) +\n    layout_tags(\"A\")\n\n\n\n\n\n\n\n\nYou can customize tags by adding a prefix and/or suffix. Note that the parent layout’s prefix and suffix are applied to all plots, including nested layouts:\n\nalign_plots(\n    p1,\n    align_plots(p2, p3) + layout_tags(1, sep = \": \"),\n    ncol = 1\n) +\n    layout_tags(\"A\", prefix = \"Fig.\")\n\n\n\n\n\n\n\n\nInstead of built-in sequences, you can provide your own tag vector:\n\nalign_plots(\n    p1,\n    align_plots(p2, p3) + layout_tags(1),\n    ncol = 1\n) +\n    layout_tags(c(\"&\", \"%\"))\n\n\n\n\n\n\n\n\nTags inherit their appearance from the plot’s theme. To modify tag styling for all plots in a layout, use the & operator:\n\nalign_plots(\n    p1,\n    align_plots(p2, p3) + layout_tags(1, sep = \": \"),\n    ncol = 1\n) +\n    layout_tags(\"A\", prefix = \"Fig.\") &\n    theme(plot.tag = element_text(color = \"red\"))\n\n\n\n\n\n\n\nIf the plot’s theme does not specify tag styling, the layout’s theme settings from layout_theme() will be used:\n\nalign_plots(\n    p1,\n    align_plots(p2, p3) + layout_tags(1, sep = \": \"),\n    ncol = 1\n) +\n    layout_tags(\"A\", prefix = \"Fig.\") +\n    layout_theme(plot.tag = element_text(color = \"red\"))"
  },
  {
    "objectID": "basics/plot-composer-tagging.html#basic-tagging",
    "href": "basics/plot-composer-tagging.html#basic-tagging",
    "title": "Plot Composer – tagging",
    "section": "",
    "text": "Set the tags argument in layout_tags() to specify the family of symbols used for tagging plots:\n\n\n\"1\": Arabic numerals (1, 2, 3, …)\n\n\"A\": Uppercase Latin letters (A, B, C, …)\n\n\"a\": Lowercase Latin letters (a, b, c, …)\n\n\"I\": Uppercase Roman numerals (I, II, III, …)\n\n\"i\": Lowercase Roman numerals (i, ii, iii, …)\n\nBy default, nested layouts receive their own tags:\n\nalign_plots(p1, align_plots(p2, p3), ncol = 1) + layout_tags(\"A\")"
  },
  {
    "objectID": "basics/plot-composer-tagging.html#suppressing-internal-tags-in-nested-layouts",
    "href": "basics/plot-composer-tagging.html#suppressing-internal-tags-in-nested-layouts",
    "title": "Plot Composer – tagging",
    "section": "",
    "text": "To treat a nested layout as a single plot with a single tag, disable its internal tags by setting tags = NULL:\n\nalign_plots(p1, align_plots(p2, p3) + layout_tags(NULL), ncol = 1) +\n    layout_tags(\"A\")"
  },
  {
    "objectID": "basics/plot-composer-tagging.html#multilevel-tagging-with-custom-separators",
    "href": "basics/plot-composer-tagging.html#multilevel-tagging-with-custom-separators",
    "title": "Plot Composer – tagging",
    "section": "",
    "text": "Apply multilevel tagging where the outer layout uses letters and the inner layout uses numbers. You can specify a separator between parent and child tags:\n\nalign_plots(\n    p1,\n    align_plots(p2, p3) + layout_tags(1, sep = \": \"),\n    ncol = 1\n) +\n    layout_tags(\"A\")"
  },
  {
    "objectID": "basics/plot-composer-tagging.html#adding-prefixes-and-suffixes",
    "href": "basics/plot-composer-tagging.html#adding-prefixes-and-suffixes",
    "title": "Plot Composer – tagging",
    "section": "",
    "text": "You can customize tags by adding a prefix and/or suffix. Note that the parent layout’s prefix and suffix are applied to all plots, including nested layouts:\n\nalign_plots(\n    p1,\n    align_plots(p2, p3) + layout_tags(1, sep = \": \"),\n    ncol = 1\n) +\n    layout_tags(\"A\", prefix = \"Fig.\")"
  },
  {
    "objectID": "basics/plot-composer-tagging.html#custom-tag-sequences",
    "href": "basics/plot-composer-tagging.html#custom-tag-sequences",
    "title": "Plot Composer – tagging",
    "section": "",
    "text": "Instead of built-in sequences, you can provide your own tag vector:\n\nalign_plots(\n    p1,\n    align_plots(p2, p3) + layout_tags(1),\n    ncol = 1\n) +\n    layout_tags(c(\"&\", \"%\"))"
  },
  {
    "objectID": "basics/plot-composer-tagging.html#tag-appearance-and-theming",
    "href": "basics/plot-composer-tagging.html#tag-appearance-and-theming",
    "title": "Plot Composer – tagging",
    "section": "",
    "text": "Tags inherit their appearance from the plot’s theme. To modify tag styling for all plots in a layout, use the & operator:\n\nalign_plots(\n    p1,\n    align_plots(p2, p3) + layout_tags(1, sep = \": \"),\n    ncol = 1\n) +\n    layout_tags(\"A\", prefix = \"Fig.\") &\n    theme(plot.tag = element_text(color = \"red\"))\n\n\n\n\n\n\n\nIf the plot’s theme does not specify tag styling, the layout’s theme settings from layout_theme() will be used:\n\nalign_plots(\n    p1,\n    align_plots(p2, p3) + layout_tags(1, sep = \": \"),\n    ncol = 1\n) +\n    layout_tags(\"A\", prefix = \"Fig.\") +\n    layout_theme(plot.tag = element_text(color = \"red\"))"
  },
  {
    "objectID": "basics/circle.html",
    "href": "basics/circle.html",
    "title": "Circlular plot",
    "section": "",
    "text": "Circlular plot\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\nset.seed(123)\n# Prepare heatmap matrix\nmat &lt;- matrix(\n    rnorm(100, mean = 0, sd = 2),\n    nrow = 10, ncol = 10,\n    dimnames = list(paste0(\"G\", 1:10), paste0(\"S\", 1:10))\n)\n\nConstruct a circular heatmap layout using ggalign’s grammar\n\ncircle_discrete(mat, radial = coord_radial(inner.radius = 0.1)) +\n\n    # add a dendrogram\n    align_dendro(aes(color = branch), k = 3L, size = 0.5) +\n    scale_color_brewer(palette = \"Dark2\") +\n\n    # add a heatmap\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() +\n\n    # add a single tile for each group\n    ggalign(NULL, size = 0.1) +\n    geom_tile(aes(y = 1L, fill = .panel)) +\n    scale_fill_brewer(palette = \"Dark2\", guide = \"none\") &\n    theme_no_axes(\"y\")"
  },
  {
    "objectID": "real-world-data/pan-cancer-immune-pathways.html",
    "href": "real-world-data/pan-cancer-immune-pathways.html",
    "title": "Disturbance of Immune-Related Pathways between Normal and Tumor Tissues in Pan-cancer",
    "section": "",
    "text": "Disturbance of Immune-Related Pathways between Normal and Tumor Tissues in Pan-cancer\nThe data were obtained fromhttps://pmc.ncbi.nlm.nih.gov/articles/PMC9856581/#app1-cancers-15-00342.\nFor demonstration purposes, we randomly selected five pathways.\nThe dataset can be downloaded from Data Repository.\n\ndata &lt;- readxl::read_xlsx(datasource(\"pan-cancer-immune-pathways.xlsx\"), skip = 1L)\nset.seed(3L)\n\n# Randomly select 5 pathways (rows 2–18 cover the main data)\nselected &lt;- sample(2:18, 5)\n\n# Extract logFC and adjusted p-values for the selected pathways\nlogFC &lt;- data[selected, c(1, which(as.character(data[1, ]) == \"logFC\"))]\nadj.P &lt;- data[selected, c(1, which(as.character(data[1, ]) == \"adj.P\"))]\nnames(adj.P) &lt;- names(logFC)\n\n# Convert to numeric matrix: pathways as columns, tumor as rows\nlogFC &lt;- dplyr::mutate(logFC, dplyr::across(!pathway, as.numeric)) |&gt;\n    tibble::column_to_rownames(var = \"pathway\") |&gt;\n    as.matrix() |&gt;\n    t()\nadj.P &lt;- dplyr::mutate(adj.P, dplyr::across(!pathway, as.numeric)) |&gt;\n    tibble::column_to_rownames(var = \"pathway\") |&gt;\n    as.matrix() |&gt;\n    t()\n\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\ncircle_discrete(logFC,\n    radial = coord_radial(start = pi / 2, end = pi * 2, expand = FALSE),\n    sector_spacing = 5 * pi / 180,\n    theme = theme(plot.margin = margin(l = 5, t = 5, b = 6, unit = \"mm\"))\n) +\n    # Align dendrogram above the radial sectors, cluster conditions into 5 groups\n    align_dendro(aes(color = branch), k = 5L, size = 1) +\n    theme_no_axes(\"y\") +\n    scale_color_brewer(palette = \"Dark2\") +\n\n    # add heatmap plot\n    ggalign(mapping = aes(y = .column_names, fill = value)) +\n    geom_tile(width = 1, height = 1) +\n    geom_text(aes(label = \"*\"), data = function(dd) {\n        dd$pvalue &lt;- adj.P[cbind(dd$.row_index, dd$.column_index)]\n        dplyr::filter(dd, pvalue &lt; 0.05)\n    }) +\n    scale_fill_gradient2(\n        low = \"blue\", high = \"red\",\n        name = \"logFC\",\n        limits = c(-1, 1),\n        breaks = c(-0.5, 0, 0.5)\n    ) +\n    guides(r = \"none\", r.sec = \"axis\", theta = guide_axis_theta(angle = 0)) +\n    theme(axis.text.theta = element_text())"
  },
  {
    "objectID": "real-world-data/tcga-laml-oncoplot.html",
    "href": "real-world-data/tcga-laml-oncoplot.html",
    "title": "Oncoplot of TCGA LAML Mutation Data",
    "section": "",
    "text": "Oncoplot of TCGA LAML Mutation Data\nWe utilize the TCGA LAML mutation dataset included in the R maftools package.\nTo reduce complexity, we randomly sample 20 tumor samples. The data preparation code is initially collapsed in the source but can be expanded for inspection.\n\nCode# load data from `maftools`\nlaml.maf &lt;- system.file(\"extdata\", \"tcga_laml.maf.gz\", package = \"maftools\")\n# clinical information containing survival information and histology. This is optional\nlaml.clin &lt;- system.file(\"extdata\", \"tcga_laml_annot.tsv\", package = \"maftools\")\nlaml &lt;- maftools::read.maf(\n    maf = laml.maf,\n    clinicalData = laml.clin,\n    verbose = FALSE\n)\nset.seed(25) # 2, 11, 20, 25, 29, 32\nnew_laml &lt;- maftools::subsetMaf(laml,\n    tsb = sample(maftools::getClinicalData(laml)$Tumor_Sample_Barcode, 20)\n)\n#&gt; -Processing clinical data\n\n\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\nggoncoplot(\n    new_laml,\n    n_top = 10, collapse_vars = FALSE, filling = FALSE,\n    remove_empty_samples = FALSE\n) +\n    geom_subtile(aes(fill = value),\n        ncol = 1L, height = 0.8,\n        show.legend = TRUE\n    ) +\n    theme_no_axes(\"x\") +\n\n    # add top annotation -------------------------------\n    anno_top(size = 0.2) +\n    ggalign(\n        data = function(data) {\n            vars &lt;- ggalign_lvls(data)\n            data &lt;- ggalign_attr(data, \"sample_summary\")\n            as.matrix(data[intersect(names(data), vars)])\n        }\n    ) +\n    scheme_data(function(data) {\n        data$.column_names &lt;- factor(data$.column_names, ggalign_lvls(data))\n        data\n    }) +\n    geom_bar(aes(.x, value, fill = .column_names),\n        stat = \"identity\"\n    ) +\n    guides(fill = \"none\") +\n    ylab(\"TMB\") +\n    scale_y_continuous(breaks = scales::breaks_pretty(2L)) +\n\n    # add right annotation -----------------------------\n    anno_right(size = 0.4) -\n    # remove bottom spaces of the right annotation when aligning\n    scheme_align(free_spaces = \"b\") +\n\n    # add the text percent for the alterated samples in the right annotation\n    ggalign(\n        data = function(data) {\n            # Atomic vector will be converted into a data frame.\n            ggalign_attr(data, \"gene_summary\")$AlteredSamples /\n                ggalign_attr(data, \"n_samples\")\n        }\n    ) +\n    geom_text(aes(1, label = scales::label_percent()(value)),\n        hjust = 1.2, size = 5, family = \"Helvetica\"\n    ) +\n    scale_x_continuous(\n        expand = expansion(),\n        name = NULL, breaks = NULL,\n        limits = c(0, 1)\n    ) +\n    theme(plot.margin = margin()) +\n\n    # add the bar plot in the right annotation\n    ggalign(data = function(data) {\n        vars &lt;- ggalign_lvls(data)\n        data &lt;- ggalign_attr(data, \"variant_weights\")\n        as.matrix(data[intersect(names(data), vars)])\n    }) +\n    scheme_data(function(data) {\n        data$.column_names &lt;- factor(data$.column_names, ggalign_lvls(data))\n        data\n    }) +\n    geom_bar(aes(value, fill = .column_names),\n        stat = \"identity\",\n        orientation = \"y\"\n    ) +\n    guides(fill = \"none\") +\n    # labs(fill = \"right\") +\n    xlab(\"Variant weights\") +\n    scale_x_continuous(breaks = scales::breaks_pretty(1)) -\n    # we apply the scale mapping to\n    # - the top and right annotation: `position = \"tr\"`\n    # - the main plot: `position = \"i\"`\n    quad_scope(\n        scale_fill_brewer(\n            \"Mutations\",\n            palette = \"Dark2\",\n            na.translate = FALSE, drop = FALSE\n        ),\n        position = \"tri\"\n    ) +\n\n    # add bottom annotation ----------------------------\n    anno_bottom(size = 0.2) +\n    # add bar plot in the bottom annotation\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"titv\")$fraction.contribution\n        as.matrix(data[-1L])\n    }) +\n    geom_bar(aes(y = value, fill = .column_names), stat = \"identity\") +\n    ylab(\"Ti/Tv\") +\n    scale_y_continuous(breaks = scales::breaks_pretty(3L)) +\n    scale_fill_brewer(\"Ti/Tv\", palette = \"Set2\", na.translate = FALSE)\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles"
  },
  {
    "objectID": "real-world-data/complexheatmap-gene-expression.html",
    "href": "real-world-data/complexheatmap-gene-expression.html",
    "title": "Heatmap of gene expression matrix",
    "section": "",
    "text": "Heatmap of gene expression matrix\nWe utilize the gene expression dataset included in the R ComplexHeatmap package to reproduce the multi-panel gene expression heatmap from https://jokergoo.github.io/ComplexHeatmap-reference/book/more-examples.html.\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\nWe load the example dataset from ComplexHeatmap and process it for visualization.\n\nexpr &lt;- readRDS(system.file(\n    \"extdata\", \"gene_expression.rds\",\n    package = \"ComplexHeatmap\"\n))\nmat &lt;- as.matrix(expr[, grep(\"cell\", colnames(expr))])\nbase_mean &lt;- rowMeans(mat)\nmat_scaled &lt;- t(apply(mat, 1, scale))\ntype &lt;- gsub(\"s\\\\d+_\", \"\", colnames(mat))\n\n\nheat1 &lt;- ggheatmap(mat_scaled) -\n    scheme_align(free_spaces = \"l\") +\n    scale_y_continuous(breaks = NULL) +\n    scale_fill_viridis_c(option = \"magma\") +\n    # add dendrogram for this heatmap\n    anno_top() +\n    align_dendro() +\n    # add a block for the heatmap column\n    ggalign(data = type, size = unit(1, \"cm\")) +\n    geom_tile(aes(y = 1, fill = factor(value))) +\n    scale_y_continuous(breaks = NULL, name = NULL) +\n    scale_fill_brewer(\n        palette = \"Set1\", name = \"type\",\n        guide = guide_legend(position = \"top\")\n    )\n\nheat2 &lt;- ggheatmap(base_mean, width = unit(2, \"cm\")) +\n    scale_y_continuous(breaks = NULL) +\n    scale_x_continuous(name = \"base mean\", breaks = FALSE) +\n    scale_fill_gradientn(colours = c(\"#2600D1FF\", \"white\", \"#EE3F3FFF\")) +\n    # set the active context of the heatmap to the top\n    # and set the size of the top stack\n    anno_top(size = unit(4, \"cm\")) +\n    # add box plot in the heatmap top\n    ggalign() +\n    geom_boxplot(aes(y = value, fill = factor(.extra_panel))) +\n    scale_x_continuous(expand = expansion(), breaks = NULL) +\n    scale_fill_brewer(\n        palette = \"Dark2\", name = \"base mean\",\n        guide = guide_legend(position = \"top\")\n    ) +\n    theme(axis.title.y = element_blank())\n\nheat3 &lt;- ggheatmap(expr$type, width = unit(2, \"cm\")) +\n    scale_fill_brewer(palette = \"Set3\", name = \"gene type\") +\n    scale_x_continuous(breaks = NULL, name = \"gene type\") +\n    # add barplot in the top annotation, and remove the spaces in the y-axis\n    anno_top() -\n    scheme_align(free_spaces = \"lr\") +\n    ggalign() +\n    geom_bar(\n        aes(.extra_panel, fill = factor(value)),\n        position = position_fill()\n    ) +\n    scale_y_continuous(expand = expansion()) +\n    scale_fill_brewer(palette = \"Set3\", name = \"gene type\", guide = \"none\") -\n    scheme_theme(plot.margin = margin())\n\nstack_alignh(mat_scaled) +\n    stack_active(sizes = c(0.2, 1, 1)) +\n    # group stack rows into 5 groups\n    align_kmeans(centers = 5L) +\n    # add a block plot for each group in the stack\n    ggalign(size = unit(1, \"cm\"), data = NULL) +\n    geom_tile(aes(x = 1, fill = factor(.panel))) +\n    scale_fill_brewer(palette = \"Dark2\", name = \"Kmeans group\") +\n    scale_x_continuous(breaks = NULL, name = NULL) +\n    # add a heatmap plot in the stack\n    heat1 +\n    # add another heatmap in the stack\n    heat2 +\n    # we move into the stack layout\n    stack_active() +\n    # add a point plot\n    ggalign(data = expr$length, size = unit(2, \"cm\")) +\n    geom_point(aes(x = value)) +\n    labs(x = \"length\") +\n    theme(\n        panel.border = element_rect(fill = NA),\n        axis.text.x = element_text(angle = -60, hjust = 0)\n    ) +\n    # add another heatmap\n    heat3 &\n    theme(\n        plot.background = element_blank(),\n        panel.background = element_blank(),\n        legend.background = element_blank()\n    )\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "gallery",
    "section": "",
    "text": "Circlular plot\n\n\n\ncircle_discrete()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nComplexHeatmap Reproduction\n\n\n\nggheatmap()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nHeatmap\n\n\n\nggheatmap()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nHeatmap with different shapes\n\n\n\nggheatmap()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nMarginal Plot\n\n\n\nggside()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nPlot Composer - Basics\n\n\n\nalign_plots()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nPlot Composer - Inset\n\n\n\nalign_plots()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nPlot Composer – Arbitrary Plots\n\n\n\nalign_plots()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nPlot Composer – tagging\n\n\n\nalign_plots()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nStacked bar\n\n\n\nstack_discrete()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nUsing images as points in ggplot2\n\n\n\ngeom_magick()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "advanced/mark.html",
    "href": "advanced/mark.html",
    "title": "Annotation observations",
    "section": "",
    "text": "Annotation observations\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\nset.seed(123)\n# Prepare heatmap matrix\nmat &lt;- matrix(\n    rnorm(100, mean = 0, sd = 2),\n    nrow = 10, ncol = 10,\n    dimnames = list(paste0(\"G\", 1:10), paste0(\"S\", 1:10))\n)\n\nBy default, when no manual observations were selected, ggmark() will select all observations and split them based on the groups defined in the layout.\n\nset.seed(123)\nggheatmap(mat) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(mark_line()) +\n    geom_boxplot(aes(.names, value)) +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can also annotate a specific subset of observations. For example, to annotate only rows 1–3 and 6–10:\n\nset.seed(123)\nggheatmap(mat) +\n    anno_right() +\n    align_kmeans(3L) +\n    # Select and annotate rows 1–3 and 6–10 only\n    ggmark(mark_line(1:3, 6:10)) +\n    geom_boxplot(aes(.names, value)) +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nFor more details, please visit https://yunuuuu.github.io/ggalign-book/annotate-observations.html"
  },
  {
    "objectID": "advanced/phylogenetic-trees.html",
    "href": "advanced/phylogenetic-trees.html",
    "title": "Visualizing Phylogenetic Trees",
    "section": "",
    "text": "ggalign provides direct support for phylo objects from the ape package, allowing you to visualize phylogenetic trees alongside other data in an integrated way.\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\nn &lt;- 100\np &lt;- 3\nset.seed(3)\ntr &lt;- ape::rcoal(n)\nx &lt;- matrix(runif(p * n), n, p)\n\nNote that you can also use stack_discrete() to display the tree in a stacked arrangement rather than in a radial layout. For this documentation, we illustrate examples using circle_discrete() as it is the most commonly used approach.\n\n\ncircle_discrete(x,\n    radial = coord_radial(inner.radius = 0.2, rotate.angle = TRUE)\n) +\n    align_phylo(tr) +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c()\n\n\n\n\n\n\n\nThe underlying data passed to align_phylo() includes both tip and internal node information. Edge data is stored as a ggalign attribute, and you can retrieve it using ggalign_attr(). See ?fortify_data_frame.phylo for details.\n\ncircle_discrete(x,\n    radial = coord_radial(inner.radius = 0.2, rotate.angle = TRUE)\n) +\n    align_phylo(tr) +\n    geom_point() +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() &\n    scale_y_continuous(breaks = NULL)\n\n\n\n\n\n\n\n\n\ngroups &lt;- cutree(as.hclust(tr), k = 3)\n\nBy default, align_phylo() will add a single phylogenetic tree, and align_group() can then facet the data by clade:\n\ncircle_discrete(x,\n    radial = coord_radial(inner.radius = 0.2, rotate.angle = TRUE)\n) +\n    align_phylo(tr, mapping = aes(color = clade)) +\n    geom_point() +\n    align_group(groups) +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() &\n    scale_y_continuous(breaks = NULL)\n\n\n\n\n\n\n\n\nIf groups are already set before adding the phylogenetic tree, you can set split = TRUE in align_phylo() to automatically split the tree into multiple subtrees, one for each group.\n\ncircle_discrete(x,\n    radial = coord_radial(inner.radius = 0.2, rotate.angle = TRUE)\n) +\n    align_group(groups) +\n    align_phylo(tr, mapping = aes(color = clade), split = TRUE) +\n    geom_point() +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() &\n    scale_y_continuous(breaks = NULL)"
  },
  {
    "objectID": "advanced/phylogenetic-trees.html#basic-phylogenetic-tree-alignment",
    "href": "advanced/phylogenetic-trees.html#basic-phylogenetic-tree-alignment",
    "title": "Visualizing Phylogenetic Trees",
    "section": "",
    "text": "circle_discrete(x,\n    radial = coord_radial(inner.radius = 0.2, rotate.angle = TRUE)\n) +\n    align_phylo(tr) +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c()\n\n\n\n\n\n\n\nThe underlying data passed to align_phylo() includes both tip and internal node information. Edge data is stored as a ggalign attribute, and you can retrieve it using ggalign_attr(). See ?fortify_data_frame.phylo for details.\n\ncircle_discrete(x,\n    radial = coord_radial(inner.radius = 0.2, rotate.angle = TRUE)\n) +\n    align_phylo(tr) +\n    geom_point() +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() &\n    scale_y_continuous(breaks = NULL)"
  },
  {
    "objectID": "advanced/phylogenetic-trees.html#grouping-by-clades",
    "href": "advanced/phylogenetic-trees.html#grouping-by-clades",
    "title": "Visualizing Phylogenetic Trees",
    "section": "",
    "text": "groups &lt;- cutree(as.hclust(tr), k = 3)\n\nBy default, align_phylo() will add a single phylogenetic tree, and align_group() can then facet the data by clade:\n\ncircle_discrete(x,\n    radial = coord_radial(inner.radius = 0.2, rotate.angle = TRUE)\n) +\n    align_phylo(tr, mapping = aes(color = clade)) +\n    geom_point() +\n    align_group(groups) +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() &\n    scale_y_continuous(breaks = NULL)"
  },
  {
    "objectID": "advanced/phylogenetic-trees.html#splitting-into-multiple-subtrees",
    "href": "advanced/phylogenetic-trees.html#splitting-into-multiple-subtrees",
    "title": "Visualizing Phylogenetic Trees",
    "section": "",
    "text": "If groups are already set before adding the phylogenetic tree, you can set split = TRUE in align_phylo() to automatically split the tree into multiple subtrees, one for each group.\n\ncircle_discrete(x,\n    radial = coord_radial(inner.radius = 0.2, rotate.angle = TRUE)\n) +\n    align_group(groups) +\n    align_phylo(tr, mapping = aes(color = clade), split = TRUE) +\n    geom_point() +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() &\n    scale_y_continuous(breaks = NULL)"
  },
  {
    "objectID": "advanced.html",
    "href": "advanced.html",
    "title": "gallery",
    "section": "",
    "text": "Annotation observations\n\n\n\nggheatmap()\n\nggmark()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nUpSet-style Plot\n\n\n\nggupset()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nVisualizing Phylogenetic Trees\n\n\n\ncircle_discrete()\n\nalign_phylo()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\ntanglegram\n\n\n\nstack_cross()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "real-world-data.html",
    "href": "real-world-data.html",
    "title": "gallery",
    "section": "",
    "text": "Disturbance of Immune-Related Pathways between Normal and Tumor Tissues in Pan-cancer\n\n\n\ncircle_discrete()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nGenomic density and Rainfall plot\n\n\n\ncircle_genomic()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nHeatmap of gene expression matrix\n\n\n\nggheatmap()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nMeasles Vaccine Heatmap\n\n\n\nggheatmap()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nOncoplot of TCGA LAML Mutation Data\n\n\n\nggoncoplot()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nPan-cancer analysis of cell type distribution and abundance at single-cell resolution\n\n\n\nggheatmap()\n\nggmark()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "advanced/upset.html",
    "href": "advanced/upset.html",
    "title": "UpSet-style Plot",
    "section": "",
    "text": "UpSet-style Plot\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\nCreate a toy list of sets, Each element in the list is a character vector (simulating a set of items)\n\nset.seed(123)\nlt &lt;- list(\n    a = sample(letters, 5),\n    b = sample(letters, 10),\n    c = sample(letters, 15)\n)\n\n# 'tune()' converts the list into an UpSet-compatible format\n# For lists, the shape is automatically set to 'upset',\n# so there’s no need to manually specify the second argument\nggupset(tune(lt)) +\n    # fill is used for background rect\n    scale_fill_manual(values = c(\"#F0F0F0\", \"white\"), guide = \"none\") +\n    # color is used for background rect\n    scale_color_manual(values = c(\"grey\", \"black\"), guide = \"none\") +\n\n    # Add top annotation showing the size of each intersection\n    anno_top(size = 0.5) +\n    ggalign(data = function(d) ggalign_attr(d, \"intersection_sizes\")) +\n    geom_bar(aes(y = .data$value), stat = \"identity\") +\n\n    # Add right annotation showing the size of each original set\n    anno_right(size = 0.5) +\n    ggalign(data = function(d) ggalign_attr(d, \"set_sizes\")) +\n    geom_bar(aes(x = .data$value), stat = \"identity\", orientation = \"y\")"
  },
  {
    "objectID": "advanced/tanglegram.html",
    "href": "advanced/tanglegram.html",
    "title": "tanglegram",
    "section": "",
    "text": "tanglegram\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\nset.seed(123)\n# Prepare heatmap matrix\nmat1 &lt;- matrix(\n    rnorm(100, mean = 0, sd = 2),\n    nrow = 10, ncol = 10,\n    dimnames = list(paste0(\"G\", 1:10), paste0(\"S\", 1:10))\n)\nmat2 &lt;- matrix(\n    rnorm(100, mean = 0, sd = 2),\n    nrow = 10, ncol = 10,\n    dimnames = list(paste0(\"G\", 1:10), paste0(\"S\", 1:10))\n)\n\nThis example demonstrates how to create a tanglegram—a paired visualization of two dendrogram-aligned with cross-links between related elements.\n\nstack_crossh(mat1) +\n    align_dendro(aes(color = branch), k = 3L) +\n    scale_x_reverse() +\n    cross_link(link_line(), data = mat2) +\n    align_dendro(aes(color = branch), k = 2L) -\n    no_expansion(\"x\") -\n    scale_color_brewer(palette = \"Dark2\") -\n    theme(plot.margin = margin())"
  },
  {
    "objectID": "real-world-data/single-cell-workflow.html",
    "href": "real-world-data/single-cell-workflow.html",
    "title": "Pan-cancer analysis of cell type distribution and abundance at single-cell resolution",
    "section": "",
    "text": "library(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\nThe raw data were obtained from https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE210347. A detailed description of the preprocessing workflow can be found here: https://github.com/Yunuuuu/ggalign-research/blob/main/Figure%206-data-preprocess.qmd. The processed dataset can be downloaded from Data Repository.\n\n\numap_subset &lt;- readRDS(datasource(\"umap_subset.rds\"))\nsummarized &lt;- readRDS(datasource(\"summarized.rds\"))\numap &lt;- readRDS(datasource(\"umap.rds\"))\nclidata &lt;- readRDS(datasource(\"clidata.rds\"))\n\n\nThe following function creates an axis guide that optionally truncates at the lower and/or upper ends:\n\nguide_axis_trunc &lt;- function(lower = NULL, upper = NULL) {\n    if (is.null(lower) && is.null(upper)) {\n        return(ggplot2::guide_axis(cap = \"both\"))\n    }\n    ggplot2::ggproto(\n        NULL,\n        ggplot2::guide_axis(),\n        build_decor = function(self, decor, grobs, elements, params) {\n            if (ggplot2:::empty(decor)) {\n                return(ggplot2::zeroGrob())\n            }\n            if (!is.null(lower)) {\n                decor[[params$aesthetic]][1L] &lt;- as.numeric(lower)\n            }\n            if (!is.null(upper)) {\n                decor[[params$aesthetic]][2L] &lt;- as.numeric(upper)\n            }\n            ggplot2::element_grob(\n                elements$line,\n                x = grid::unit(decor$x, \"npc\"),\n                y = grid::unit(decor$y, \"npc\")\n            )\n        }\n    )\n}\n\n\n\nggheatmap(summarized$num, filling = FALSE) -\n    # main plot\n    scheme_data(function(data) {\n        data$average &lt;- summarized$ave[cbind(data$.row_index, data$.column_index)]\n        data\n    }) +\n    geom_point(aes(fill = average, size = value), shape = 21) +\n    scale_fill_viridis_c(name = \"Mean\") +\n    scale_size_continuous(name = \"Proportion\", range = c(1, 4)) +\n    theme_bw() +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        strip.text.y.right = element_blank(),\n        plot.margin = margin(),\n        strip.background = element_rect(colour = NA),\n        strip.text = element_text(face = \"bold\")\n    ) +\n    ggh4x::facet_grid2(\n        strip = ggh4x::strip_themed(\n            clip = \"off\",\n            background_x = ggh4x::elem_list_rect(\n                fill = RColorBrewer::brewer.pal(6, \"Set2\"),\n                colour = NA\n            )\n        ),\n        labeller = labeller(\n            .panel_x = function(x) {\n                x[x == \"Endothelium\"] &lt;- \"Endo-\\nthelium\"\n                x[x == \"Lymphocyte\"] &lt;- \"Lympho-\\ncyte\"\n                x\n            }\n        )\n    ) +\n    scheme_align(free_spaces = \"l\") +\n\n    # top\n    anno_top() +\n    align_group(summarized$column_grp) +\n\n    # right\n    anno_right() +\n    align_group(summarized$row_grp) +\n\n    # left -----------------------------------------\n    anno_left(size = 0.6) +\n    ggmark(\n        # define how to draw the links\n        mark_draw(function(panel, link) {\n            dist &lt;- (panel$yend - panel$y) / nlevels(link$link_panel)\n            link_list &lt;- split(link, link$link_panel)\n            ans &lt;- vector(\"list\", length(link_list))\n            for (i in seq_along(link_list)) {\n                dd &lt;- .subset2(link_list, i)\n                ans[[i]] &lt;- data.frame(\n                    x = c(\n                        panel$x, panel$xend,\n                        max(dd$xend), min(dd$x)\n                    ),\n                    y = c(\n                        panel$y + dist * (i - 1L),\n                        panel$y + dist * i,\n                        max(dd$yend), min(dd$y)\n                    )\n                )\n            }\n            ans &lt;- dplyr::bind_rows(ans)\n            element_grob(\n                element_polygon(\n                    fill = RColorBrewer::brewer.pal(6, \"Set2\"),\n                    color = NA,\n                    linewidth = 0.5,\n                    linetype = 1,\n                    alpha = NA,\n                    lineend = \"butt\",\n                    linejoin = \"round\",\n                    linemitre = 10\n                ),\n                x = ans$x, y = ans$y,\n                id.lengths = vctrs::vec_rep(4L, nrow(ans) / 4L),\n                default.units = \"native\"\n            )\n        }, ~ seq_len(nrow(summarized$num))),\n        mapping = aes(umap1, umap2)\n    ) +\n    scheme_data(function(data) umap) +\n    ggrastr::geom_point_rast(aes(color = celltype), size = 0, shape = 16) +\n    scale_color_brewer(\n        name = \"Celltype\", palette = \"Set2\",\n        guide = guide_legend(override.aes = list(size = 3))\n    ) +\n    ggtitle(\"UMAP\") +\n    scale_x_continuous(breaks = -10) +\n    scale_y_continuous(breaks = -10) +\n    guides(\n        x = guide_axis_trunc(upper = 0.3),\n        y = guide_axis_trunc(upper = 0.3)\n    ) +\n    theme_no_axes() +\n    theme(\n        plot.margin = margin(t = 0.3, b = 0.3, r = 0.15, unit = \"npc\"),\n        panel.border = element_blank(),\n        axis.line = element_line(arrow = grid::arrow(length = unit(0.05, \"inches\")))\n    ) +\n\n    # right -----------------------------------------\n    # umap plot\n    anno_right() +\n    ggmark(\n        mark_tetragon(\n            .element = element_vec_rep_each(\n                element_polygon(\n                    fill = RColorBrewer::brewer.pal(6, \"Set2\"),\n                    colour = NA\n                ),\n                2L\n            )\n        ),\n        data = NULL, mapping = aes(umap1, umap2),\n        group1 = TRUE, group2 = TRUE\n    ) +\n    scheme_data(function(data) {\n        ans &lt;- umap_subset\n        ans$.panel &lt;- factor(ans$.panel, levels(data$.panel))\n        ans\n    }) +\n    ggrastr::geom_point_rast(aes(color = tissue), size = 0, shape = 16) +\n    ggsci::scale_color_d3(palette = \"category20\", guide = \"none\") +\n    theme_no_axes() +\n    theme(\n        plot.margin = margin(l = 0.15, r = 0.1, unit = \"npc\"),\n        strip.text = element_blank(),\n        strip.background = element_blank()\n    ) +\n    ggtitle(\"UMAP\") +\n\n    # box plot\n    ggmark(mark_tetragon(.element = element_polygon(\n        fill = RColorBrewer::brewer.pal(6, \"Set2\"),\n        colour = NA\n    )), size = 1.5) +\n    scheme_data(function(data) {\n        ans &lt;- clidata\n        ans$celltype &lt;- factor(ans$celltype, levels = levels(data$.panel))\n        ans &lt;- dplyr::summarise(\n            ans,\n            n = dplyr::n(),\n            .by = c(tissue, SampleID, celltype)\n        )\n        ans &lt;- dplyr::mutate(ans,\n            prop = n / sum(n),\n            .by = c(tissue, SampleID)\n        )\n        ans$.panel &lt;- ans$celltype\n        ans\n    }) +\n    geom_boxplot(aes(tissue, prop, fill = tissue)) +\n    ggsci::scale_fill_d3(palette = \"category20\", guide = \"none\") +\n    scale_y_continuous(position = \"right\", breaks = scales::pretty_breaks(2)) +\n    xlab(NULL) +\n    ylab(\"Proportion\") +\n    theme(\n        plot.margin = margin(l = 0.08, unit = \"npc\"),\n        axis.text.x = element_text(angle = -60, hjust = 0, size = 12),\n        strip.clip = \"off\",\n        strip.text = element_text(size = 10, face = \"bold\"),\n        strip.background = element_rect(color = NA)\n    ) +\n    ggh4x::facet_grid2(\n        scales = \"free_y\",\n        strip = ggh4x::strip_themed(\n            clip = \"off\",\n            background_y = ggh4x::elem_list_rect(\n                fill = rev(RColorBrewer::brewer.pal(6, \"Set2\"))\n            )\n        ),\n        labeller = labeller(\n            .panel = function(x) {\n                x[x == \"Endothelium\"] &lt;- \"Endo-\\nthelium\"\n                x\n            }\n        )\n    )"
  },
  {
    "objectID": "real-world-data/single-cell-workflow.html#load-processed-data",
    "href": "real-world-data/single-cell-workflow.html#load-processed-data",
    "title": "Pan-cancer analysis of cell type distribution and abundance at single-cell resolution",
    "section": "",
    "text": "umap_subset &lt;- readRDS(datasource(\"umap_subset.rds\"))\nsummarized &lt;- readRDS(datasource(\"summarized.rds\"))\numap &lt;- readRDS(datasource(\"umap.rds\"))\nclidata &lt;- readRDS(datasource(\"clidata.rds\"))"
  },
  {
    "objectID": "real-world-data/single-cell-workflow.html#helper-truncated-axis-guide",
    "href": "real-world-data/single-cell-workflow.html#helper-truncated-axis-guide",
    "title": "Pan-cancer analysis of cell type distribution and abundance at single-cell resolution",
    "section": "",
    "text": "The following function creates an axis guide that optionally truncates at the lower and/or upper ends:\n\nguide_axis_trunc &lt;- function(lower = NULL, upper = NULL) {\n    if (is.null(lower) && is.null(upper)) {\n        return(ggplot2::guide_axis(cap = \"both\"))\n    }\n    ggplot2::ggproto(\n        NULL,\n        ggplot2::guide_axis(),\n        build_decor = function(self, decor, grobs, elements, params) {\n            if (ggplot2:::empty(decor)) {\n                return(ggplot2::zeroGrob())\n            }\n            if (!is.null(lower)) {\n                decor[[params$aesthetic]][1L] &lt;- as.numeric(lower)\n            }\n            if (!is.null(upper)) {\n                decor[[params$aesthetic]][2L] &lt;- as.numeric(upper)\n            }\n            ggplot2::element_grob(\n                elements$line,\n                x = grid::unit(decor$x, \"npc\"),\n                y = grid::unit(decor$y, \"npc\")\n            )\n        }\n    )\n}"
  },
  {
    "objectID": "real-world-data/single-cell-workflow.html#visualization-pipeline",
    "href": "real-world-data/single-cell-workflow.html#visualization-pipeline",
    "title": "Pan-cancer analysis of cell type distribution and abundance at single-cell resolution",
    "section": "",
    "text": "ggheatmap(summarized$num, filling = FALSE) -\n    # main plot\n    scheme_data(function(data) {\n        data$average &lt;- summarized$ave[cbind(data$.row_index, data$.column_index)]\n        data\n    }) +\n    geom_point(aes(fill = average, size = value), shape = 21) +\n    scale_fill_viridis_c(name = \"Mean\") +\n    scale_size_continuous(name = \"Proportion\", range = c(1, 4)) +\n    theme_bw() +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        strip.text.y.right = element_blank(),\n        plot.margin = margin(),\n        strip.background = element_rect(colour = NA),\n        strip.text = element_text(face = \"bold\")\n    ) +\n    ggh4x::facet_grid2(\n        strip = ggh4x::strip_themed(\n            clip = \"off\",\n            background_x = ggh4x::elem_list_rect(\n                fill = RColorBrewer::brewer.pal(6, \"Set2\"),\n                colour = NA\n            )\n        ),\n        labeller = labeller(\n            .panel_x = function(x) {\n                x[x == \"Endothelium\"] &lt;- \"Endo-\\nthelium\"\n                x[x == \"Lymphocyte\"] &lt;- \"Lympho-\\ncyte\"\n                x\n            }\n        )\n    ) +\n    scheme_align(free_spaces = \"l\") +\n\n    # top\n    anno_top() +\n    align_group(summarized$column_grp) +\n\n    # right\n    anno_right() +\n    align_group(summarized$row_grp) +\n\n    # left -----------------------------------------\n    anno_left(size = 0.6) +\n    ggmark(\n        # define how to draw the links\n        mark_draw(function(panel, link) {\n            dist &lt;- (panel$yend - panel$y) / nlevels(link$link_panel)\n            link_list &lt;- split(link, link$link_panel)\n            ans &lt;- vector(\"list\", length(link_list))\n            for (i in seq_along(link_list)) {\n                dd &lt;- .subset2(link_list, i)\n                ans[[i]] &lt;- data.frame(\n                    x = c(\n                        panel$x, panel$xend,\n                        max(dd$xend), min(dd$x)\n                    ),\n                    y = c(\n                        panel$y + dist * (i - 1L),\n                        panel$y + dist * i,\n                        max(dd$yend), min(dd$y)\n                    )\n                )\n            }\n            ans &lt;- dplyr::bind_rows(ans)\n            element_grob(\n                element_polygon(\n                    fill = RColorBrewer::brewer.pal(6, \"Set2\"),\n                    color = NA,\n                    linewidth = 0.5,\n                    linetype = 1,\n                    alpha = NA,\n                    lineend = \"butt\",\n                    linejoin = \"round\",\n                    linemitre = 10\n                ),\n                x = ans$x, y = ans$y,\n                id.lengths = vctrs::vec_rep(4L, nrow(ans) / 4L),\n                default.units = \"native\"\n            )\n        }, ~ seq_len(nrow(summarized$num))),\n        mapping = aes(umap1, umap2)\n    ) +\n    scheme_data(function(data) umap) +\n    ggrastr::geom_point_rast(aes(color = celltype), size = 0, shape = 16) +\n    scale_color_brewer(\n        name = \"Celltype\", palette = \"Set2\",\n        guide = guide_legend(override.aes = list(size = 3))\n    ) +\n    ggtitle(\"UMAP\") +\n    scale_x_continuous(breaks = -10) +\n    scale_y_continuous(breaks = -10) +\n    guides(\n        x = guide_axis_trunc(upper = 0.3),\n        y = guide_axis_trunc(upper = 0.3)\n    ) +\n    theme_no_axes() +\n    theme(\n        plot.margin = margin(t = 0.3, b = 0.3, r = 0.15, unit = \"npc\"),\n        panel.border = element_blank(),\n        axis.line = element_line(arrow = grid::arrow(length = unit(0.05, \"inches\")))\n    ) +\n\n    # right -----------------------------------------\n    # umap plot\n    anno_right() +\n    ggmark(\n        mark_tetragon(\n            .element = element_vec_rep_each(\n                element_polygon(\n                    fill = RColorBrewer::brewer.pal(6, \"Set2\"),\n                    colour = NA\n                ),\n                2L\n            )\n        ),\n        data = NULL, mapping = aes(umap1, umap2),\n        group1 = TRUE, group2 = TRUE\n    ) +\n    scheme_data(function(data) {\n        ans &lt;- umap_subset\n        ans$.panel &lt;- factor(ans$.panel, levels(data$.panel))\n        ans\n    }) +\n    ggrastr::geom_point_rast(aes(color = tissue), size = 0, shape = 16) +\n    ggsci::scale_color_d3(palette = \"category20\", guide = \"none\") +\n    theme_no_axes() +\n    theme(\n        plot.margin = margin(l = 0.15, r = 0.1, unit = \"npc\"),\n        strip.text = element_blank(),\n        strip.background = element_blank()\n    ) +\n    ggtitle(\"UMAP\") +\n\n    # box plot\n    ggmark(mark_tetragon(.element = element_polygon(\n        fill = RColorBrewer::brewer.pal(6, \"Set2\"),\n        colour = NA\n    )), size = 1.5) +\n    scheme_data(function(data) {\n        ans &lt;- clidata\n        ans$celltype &lt;- factor(ans$celltype, levels = levels(data$.panel))\n        ans &lt;- dplyr::summarise(\n            ans,\n            n = dplyr::n(),\n            .by = c(tissue, SampleID, celltype)\n        )\n        ans &lt;- dplyr::mutate(ans,\n            prop = n / sum(n),\n            .by = c(tissue, SampleID)\n        )\n        ans$.panel &lt;- ans$celltype\n        ans\n    }) +\n    geom_boxplot(aes(tissue, prop, fill = tissue)) +\n    ggsci::scale_fill_d3(palette = \"category20\", guide = \"none\") +\n    scale_y_continuous(position = \"right\", breaks = scales::pretty_breaks(2)) +\n    xlab(NULL) +\n    ylab(\"Proportion\") +\n    theme(\n        plot.margin = margin(l = 0.08, unit = \"npc\"),\n        axis.text.x = element_text(angle = -60, hjust = 0, size = 12),\n        strip.clip = \"off\",\n        strip.text = element_text(size = 10, face = \"bold\"),\n        strip.background = element_rect(color = NA)\n    ) +\n    ggh4x::facet_grid2(\n        scales = \"free_y\",\n        strip = ggh4x::strip_themed(\n            clip = \"off\",\n            background_y = ggh4x::elem_list_rect(\n                fill = rev(RColorBrewer::brewer.pal(6, \"Set2\"))\n            )\n        ),\n        labeller = labeller(\n            .panel = function(x) {\n                x[x == \"Endothelium\"] &lt;- \"Endo-\\nthelium\"\n                x\n            }\n        )\n    )"
  },
  {
    "objectID": "real-world-data/genomic-density-and-rainfall-plot.html",
    "href": "real-world-data/genomic-density-and-rainfall-plot.html",
    "title": "Genomic density and Rainfall plot",
    "section": "",
    "text": "Genomic density and Rainfall plot\nRainfall plots are a powerful tool to visualize the distribution and clustering of genomic regions across the genome. Each point in a rainfall plot represents a genomic region, with:\n\nThe x-axis showing its genomic coordinate.\nThe y-axis showing the log-transformed minimal distance to its two neighboring regions (log10(dist)).\n\nClusters of nearby regions appear as dense “rainfalls” of points, making this approach ideal for identifying mutation hotspots, differentially methylated regions (DMRs), or other non-random patterns of localization.\nHowever, when region density is high, overplotting can obscure meaningful interpretation. To address this, we overlay a genomic density track that summarizes the fraction of a genomic window covered by regions—providing a smoother representation of local enrichment.\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\nThe data comes from the circlize package and includes both hyper- and hypo-methylated DMRs in the human genome.\n\nload(system.file(package = \"circlize\", \"extdata\", \"DMR.RData\", mustWork = TRUE))\nbed_data &lt;- dplyr::bind_rows(hyper = DMR_hyper, hypo = DMR_hypo, .id = \"DMR\") |&gt;\n    dplyr::relocate(DMR, .after = dplyr::last_col())\n\nif the amount of regions in a cluster is high, dots will overlap, and direct assessment of the number and density of regions in the cluster will be impossible. To overcome this limitation, additional tracks are added which visualize the genomic density of regions (defined as the fraction of a genomic window that is covered by genomic regions).\n\ncircle_genomic(\n    \"hg19\",\n    radial = coord_radial(inner.radius = 0.2, rotate.angle = TRUE),\n    direction = \"inward\",\n    theme = theme(\n        plot.margin = margin(t = 10, b = 10, l = 2, unit = \"mm\")\n    )\n) -\n    # Remove radial axes for a cleaner circular look\n    scheme_theme(\n        axis.text.r = element_blank(),\n        axis.ticks.r = element_blank()\n    ) +\n\n    # Cytoband (Ideogram) Layer ------------------\n    plot_ideogram() +\n    scale_x_continuous(\n        breaks = scales::breaks_pretty(2),\n        labels = scales::label_bytes(\"MB\")\n    ) +\n    guides(\n        r = \"none\", r.sec = \"axis\",\n        theta = guide_axis_theta(angle = 0)\n    ) +\n    theme(axis.text.theta = element_text(size = 6)) +\n\n    # add rainfall plot -----------------------\n    ggalign(bed_data) +\n    geom_point(\n        aes(middle, log10(dist), color = DMR),\n        data = function(d) {\n            d &lt;- dplyr::bind_rows(!!!lapply(\n                split(d, ~DMR), function(dd) genomic_dist(dd)\n            ))\n            d$middle &lt;- (d$start + d$end) / 2\n            d\n        }\n    ) +\n    scale_color_brewer(\n        palette = \"Dark2\",\n        guide = guide_legend(\n            position = \"inside\",\n            theme = theme(\n                legend.position.inside = c(0.5, 0.5),\n                legend.key = element_rect(color = NA),\n                legend.title = element_text(face = \"bold\")\n            )\n        )\n    ) +\n\n    # add density plot -----------------------\n    ggalign(DMR_hyper, size = 0.5) +\n    geom_density(\n        aes(middle, density, color = after_scale(fill)),\n        fill = RColorBrewer::brewer.pal(3, \"Dark2\")[1L],\n        stat = \"identity\",\n        data = function(d) {\n            d &lt;- genomic_density(d)\n            d$middle &lt;- (d$start + d$end) / 2\n            d\n        }\n    ) +\n    ggalign(DMR_hypo, size = 0.5) +\n    geom_density(\n        aes(middle, density, color = after_scale(fill)),\n        fill = RColorBrewer::brewer.pal(3, \"Dark2\")[2L],\n        stat = \"identity\",\n        data = function(d) {\n            d &lt;- genomic_density(d)\n            d$middle &lt;- (d$start + d$end) / 2\n            d\n        }\n    ) &\n    theme(panel.background = element_rect(color = \"black\", fill = NA))"
  },
  {
    "objectID": "real-world-data/measles-vaccine-heatmap.html",
    "href": "real-world-data/measles-vaccine-heatmap.html",
    "title": "Measles Vaccine Heatmap",
    "section": "",
    "text": "Measles Vaccine Heatmap\nWe utilize the measles vaccine dataset included in the R ComplexHeatmap package to reproduce the figure from https://jokergoo.github.io/ComplexHeatmap-reference/book/more-examples.html.\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\nmat &lt;- mat &lt;- readRDS(\n    system.file(\"extdata\", \"measles.rds\", package = \"ComplexHeatmap\")\n)\nggheatmap(mat, filling = FALSE) +\n    geom_tile(aes(fill = value), color = \"white\") +\n    scale_fill_gradientn(\n        colours = c(\"white\", \"cornflowerblue\", \"yellow\", \"red\"),\n        values = scales::rescale(c(0, 800, 1000, 127000), c(0, 1))\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(2, \"cm\")) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(y = value), fill = \"#FFE200\", stat = \"identity\") +\n    scale_y_continuous(expand = expansion()) +\n    ggtitle(\"Measles cases in US states 1930-2001\\nVaccine introduced 1961\") +\n    theme(plot.title = element_text(hjust = 0.5)) +\n    anno_right(size = unit(2, \"cm\")) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(x = value),\n        fill = \"#FFE200\", stat = \"identity\",\n        orientation = \"y\"\n    ) +\n    scale_x_continuous(expand = expansion(), name = NULL) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Basics",
    "section": "",
    "text": "2025-08-23\n\n\n\n\nBasics\n\n\n\n\n\n\n\n\nCirclular plot\n\n\n\ncircle_discrete()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nComplexHeatmap Reproduction\n\n\n\nggheatmap()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nHeatmap\n\n\n\nggheatmap()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nHeatmap with different shapes\n\n\n\nggheatmap()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nMarginal Plot\n\n\n\nggside()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nPlot Composer - Basics\n\n\n\nalign_plots()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nPlot Composer - Inset\n\n\n\nalign_plots()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nPlot Composer – Arbitrary Plots\n\n\n\nalign_plots()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nPlot Composer – tagging\n\n\n\nalign_plots()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nStacked bar\n\n\n\nstack_discrete()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nUsing images as points in ggplot2\n\n\n\ngeom_magick()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\nNo matching items\n\n\n\nAdvanced\n\n\n\n\n\n\n\n\nAnnotation observations\n\n\n\nggheatmap()\n\nggmark()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nUpSet-style Plot\n\n\n\nggupset()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nVisualizing Phylogenetic Trees\n\n\n\ncircle_discrete()\n\nalign_phylo()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\ntanglegram\n\n\n\nstack_cross()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\nNo matching items\n\n\n\nReal World Data\n\n\n\n\n\n\n\n\nDisturbance of Immune-Related Pathways between Normal and Tumor Tissues in Pan-cancer\n\n\n\ncircle_discrete()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nGenomic density and Rainfall plot\n\n\n\ncircle_genomic()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nHeatmap of gene expression matrix\n\n\n\nggheatmap()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nMeasles Vaccine Heatmap\n\n\n\nggheatmap()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nOncoplot of TCGA LAML Mutation Data\n\n\n\nggoncoplot()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nPan-cancer analysis of cell type distribution and abundance at single-cell resolution\n\n\n\nggheatmap()\n\nggmark()\n\n\n\n\nAug 23, 2025\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "basics/marginal-plots.html",
    "href": "basics/marginal-plots.html",
    "title": "Marginal Plot",
    "section": "",
    "text": "A marginal plot is a visualization that combines a main plot (usually a scatter plot) with additional plots in the margins of the axes. These marginal plots display the distributions of the individual variables, often using histograms, box plots, or other visual representations.\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\n\nggside(mpg, aes(displ, hwy, colour = class)) -\n    scheme_theme(theme_bw()) +\n    geom_point(size = 2) +\n    # initialize top annotation\n    anno_top(size = 0.3) +\n    # add a plot in the top annotation\n    ggalign() +\n    geom_density(aes(displ, y = after_stat(density), colour = class), position = \"stack\") +\n    # initialize right annotation\n    anno_right(size = 0.3) +\n    # add a plot in the right annotation\n    ggalign() +\n    geom_density(aes(x = after_stat(density), hwy, colour = class),\n        position = \"stack\"\n    )\n\n\n\n\n\n\n\n\n\ni2 &lt;- iris\ni2$Group &lt;- rep(c(\"Group1\", \"Group2\"), 75)\nggside(i2, aes(Sepal.Width, Sepal.Length, color = Species)) +\n    geom_point(size = 2) +\n    facet_grid(Species ~ Group) +\n    theme(\n        strip.background = element_blank(),\n        strip.text = element_blank()\n    ) +\n    anno_top(size = 0.3) +\n    ggalign() +\n    geom_density(aes(Sepal.Width, y = after_stat(density), colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(cols = vars(Group)) +\n    theme(\n        strip.text = element_text(margin = margin(5, 5, 5, 5)),\n        strip.background = element_rect(fill = \"grey\")\n    ) +\n    anno_right(size = 0.3) +\n    ggalign() +\n    geom_density(aes(x = after_stat(density), Sepal.Length, colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(rows = vars(Species)) +\n    theme(\n        strip.text = element_text(margin = margin(5, 5, 5, 5)),\n        strip.background = element_rect(fill = \"grey\")\n    ) -\n    quad_scope(scheme_theme(theme_bw()), \"tri\") &\n    scale_color_brewer(palette = \"Dark2\", guide = \"none\") &\n    scale_x_continuous(breaks = scales::pretty_breaks(3L)) &\n    scale_y_continuous(breaks = scales::pretty_breaks(3L)) &\n    theme(\n        axis.text = element_text(),\n        axis.title = element_text(face = \"bold\")\n    )\n\n\n\n\n\n\n\n\nReproduce cases in Add marginal plots of ggpubr post.\n\nggside(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n    geom_point(size = 3, alpha = 0.6) +\n    ggsci::scale_color_jco() +\n    theme_classic() +\n    anno_top(size = 0.2) +\n    ggalign() +\n    geom_density(aes(x = Sepal.Length)) +\n    theme_no_axes() +\n    anno_right(size = 0.2) +\n    ggalign() +\n    geom_density(aes(y = Sepal.Width)) +\n    theme_no_axes()\n\n\n\n\n\n\n\n\nggside(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n    geom_point(size = 3, alpha = 0.6) +\n    ggsci::scale_color_jco() +\n    theme_classic() +\n    anno_top(size = 0.2) +\n    ggalign() +\n    geom_boxplot(aes(x = Sepal.Length), fill = \"grey\") +\n    theme_no_axes() +\n    anno_right(size = 0.2) +\n    ggalign() +\n    geom_boxplot(aes(y = Sepal.Width), fill = \"grey\") +\n    theme_no_axes()\n\n\n\n\n\n\n\n\nggside(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n    geom_point(size = 3, alpha = 0.6) +\n    ggsci::scale_color_jco() +\n    theme_light() +\n    anno_top(size = 0.2) +\n    ggalign() +\n    geom_density(aes(x = Sepal.Length, fill = Species, alpha = 0.6)) +\n    theme_no_axes() +\n    anno_right(size = 0.2) +\n    ggalign() +\n    geom_density(aes(y = Sepal.Width, fill = Species), alpha = 0.6) +\n    theme_no_axes() &\n    ggsci::scale_fill_jco() &\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nggside(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n    geom_point(size = 3, alpha = 0.6) +\n    geom_smooth(method = lm) +\n    ggpubr::stat_cor() +\n    ggsci::scale_color_jco() +\n    theme_light() +\n    anno_top(size = 0.2) +\n    ggalign() +\n    geom_density(aes(x = Sepal.Length, fill = Species, alpha = 0.6)) +\n    theme_no_axes() +\n    anno_right(size = 0.2) +\n    ggalign() +\n    geom_density(aes(y = Sepal.Width, fill = Species), alpha = 0.6) +\n    theme_no_axes() &\n    ggsci::scale_fill_jco() &\n    theme(legend.position = \"none\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "basics/marginal-plots.html#scatter-plot-with-marginal-densities",
    "href": "basics/marginal-plots.html#scatter-plot-with-marginal-densities",
    "title": "Marginal Plot",
    "section": "",
    "text": "ggside(mpg, aes(displ, hwy, colour = class)) -\n    scheme_theme(theme_bw()) +\n    geom_point(size = 2) +\n    # initialize top annotation\n    anno_top(size = 0.3) +\n    # add a plot in the top annotation\n    ggalign() +\n    geom_density(aes(displ, y = after_stat(density), colour = class), position = \"stack\") +\n    # initialize right annotation\n    anno_right(size = 0.3) +\n    # add a plot in the right annotation\n    ggalign() +\n    geom_density(aes(x = after_stat(density), hwy, colour = class),\n        position = \"stack\"\n    )"
  },
  {
    "objectID": "basics/marginal-plots.html#facetted-marginal-plots",
    "href": "basics/marginal-plots.html#facetted-marginal-plots",
    "title": "Marginal Plot",
    "section": "",
    "text": "i2 &lt;- iris\ni2$Group &lt;- rep(c(\"Group1\", \"Group2\"), 75)\nggside(i2, aes(Sepal.Width, Sepal.Length, color = Species)) +\n    geom_point(size = 2) +\n    facet_grid(Species ~ Group) +\n    theme(\n        strip.background = element_blank(),\n        strip.text = element_blank()\n    ) +\n    anno_top(size = 0.3) +\n    ggalign() +\n    geom_density(aes(Sepal.Width, y = after_stat(density), colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(cols = vars(Group)) +\n    theme(\n        strip.text = element_text(margin = margin(5, 5, 5, 5)),\n        strip.background = element_rect(fill = \"grey\")\n    ) +\n    anno_right(size = 0.3) +\n    ggalign() +\n    geom_density(aes(x = after_stat(density), Sepal.Length, colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(rows = vars(Species)) +\n    theme(\n        strip.text = element_text(margin = margin(5, 5, 5, 5)),\n        strip.background = element_rect(fill = \"grey\")\n    ) -\n    quad_scope(scheme_theme(theme_bw()), \"tri\") &\n    scale_color_brewer(palette = \"Dark2\", guide = \"none\") &\n    scale_x_continuous(breaks = scales::pretty_breaks(3L)) &\n    scale_y_continuous(breaks = scales::pretty_breaks(3L)) &\n    theme(\n        axis.text = element_text(),\n        axis.title = element_text(face = \"bold\")\n    )"
  },
  {
    "objectID": "basics/marginal-plots.html#reproducing-ggpubr-marginal-plot-examples",
    "href": "basics/marginal-plots.html#reproducing-ggpubr-marginal-plot-examples",
    "title": "Marginal Plot",
    "section": "",
    "text": "Reproduce cases in Add marginal plots of ggpubr post.\n\nggside(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n    geom_point(size = 3, alpha = 0.6) +\n    ggsci::scale_color_jco() +\n    theme_classic() +\n    anno_top(size = 0.2) +\n    ggalign() +\n    geom_density(aes(x = Sepal.Length)) +\n    theme_no_axes() +\n    anno_right(size = 0.2) +\n    ggalign() +\n    geom_density(aes(y = Sepal.Width)) +\n    theme_no_axes()\n\n\n\n\n\n\n\n\nggside(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n    geom_point(size = 3, alpha = 0.6) +\n    ggsci::scale_color_jco() +\n    theme_classic() +\n    anno_top(size = 0.2) +\n    ggalign() +\n    geom_boxplot(aes(x = Sepal.Length), fill = \"grey\") +\n    theme_no_axes() +\n    anno_right(size = 0.2) +\n    ggalign() +\n    geom_boxplot(aes(y = Sepal.Width), fill = \"grey\") +\n    theme_no_axes()\n\n\n\n\n\n\n\n\nggside(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n    geom_point(size = 3, alpha = 0.6) +\n    ggsci::scale_color_jco() +\n    theme_light() +\n    anno_top(size = 0.2) +\n    ggalign() +\n    geom_density(aes(x = Sepal.Length, fill = Species, alpha = 0.6)) +\n    theme_no_axes() +\n    anno_right(size = 0.2) +\n    ggalign() +\n    geom_density(aes(y = Sepal.Width, fill = Species), alpha = 0.6) +\n    theme_no_axes() &\n    ggsci::scale_fill_jco() &\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nggside(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n    geom_point(size = 3, alpha = 0.6) +\n    geom_smooth(method = lm) +\n    ggpubr::stat_cor() +\n    ggsci::scale_color_jco() +\n    theme_light() +\n    anno_top(size = 0.2) +\n    ggalign() +\n    geom_density(aes(x = Sepal.Length, fill = Species, alpha = 0.6)) +\n    theme_no_axes() +\n    anno_right(size = 0.2) +\n    ggalign() +\n    geom_density(aes(y = Sepal.Width, fill = Species), alpha = 0.6) +\n    theme_no_axes() &\n    ggsci::scale_fill_jco() &\n    theme(legend.position = \"none\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "basics/heatmap-with-different-shape.html",
    "href": "basics/heatmap-with-different-shape.html",
    "title": "Heatmap with different shapes",
    "section": "",
    "text": "library(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\nCreate a heatmap where each cell is represented by a pie chart, with slice angles proportional to the values:\n\nset.seed(123)\nggheatmap(matrix(runif(360L), nrow = 20L), filling = NULL) +\n    geom_pie(aes(angle = value * 360, fill = value))\n\n\n\n\n\n\n\nFor more complex customizations of pie charts, you can try using ggforce::geom_arc_bar() instead.\n\nVisualize a smaller heatmap matrix using 3D tiles where height and fill color represent values:\n\nset.seed(123)\nsmall_mat &lt;- matrix(rnorm(81), nrow = 9)\nrownames(small_mat) &lt;- paste0(\"row\", seq_len(nrow(small_mat)))\ncolnames(small_mat) &lt;- paste0(\"column\", seq_len(ncol(small_mat)))\nggheatmap(small_mat,\n    filling = FALSE,\n    theme = theme(\n        legend.box.spacing = unit(10, \"mm\"),\n        plot.margin = margin(t = 15, unit = \"mm\")\n    )\n) +\n    geom_tile3d(\n        aes(fill = value, z = value, width = 0.8, height = 0.8),\n        color = \"black\"\n    ) +\n    scale_fill_viridis_c(\n        option = \"plasma\",\n        breaks = scales::breaks_pretty(3L)\n    ) +\n    coord_cartesian(clip = \"off\")"
  },
  {
    "objectID": "basics/heatmap-with-different-shape.html#basic-heatmap-with-pie-chart",
    "href": "basics/heatmap-with-different-shape.html#basic-heatmap-with-pie-chart",
    "title": "Heatmap with different shapes",
    "section": "",
    "text": "Create a heatmap where each cell is represented by a pie chart, with slice angles proportional to the values:\n\nset.seed(123)\nggheatmap(matrix(runif(360L), nrow = 20L), filling = NULL) +\n    geom_pie(aes(angle = value * 360, fill = value))\n\n\n\n\n\n\n\nFor more complex customizations of pie charts, you can try using ggforce::geom_arc_bar() instead."
  },
  {
    "objectID": "basics/heatmap-with-different-shape.html#d-heatmap",
    "href": "basics/heatmap-with-different-shape.html#d-heatmap",
    "title": "Heatmap with different shapes",
    "section": "",
    "text": "Visualize a smaller heatmap matrix using 3D tiles where height and fill color represent values:\n\nset.seed(123)\nsmall_mat &lt;- matrix(rnorm(81), nrow = 9)\nrownames(small_mat) &lt;- paste0(\"row\", seq_len(nrow(small_mat)))\ncolnames(small_mat) &lt;- paste0(\"column\", seq_len(ncol(small_mat)))\nggheatmap(small_mat,\n    filling = FALSE,\n    theme = theme(\n        legend.box.spacing = unit(10, \"mm\"),\n        plot.margin = margin(t = 15, unit = \"mm\")\n    )\n) +\n    geom_tile3d(\n        aes(fill = value, z = value, width = 0.8, height = 0.8),\n        color = \"black\"\n    ) +\n    scale_fill_viridis_c(\n        option = \"plasma\",\n        breaks = scales::breaks_pretty(3L)\n    ) +\n    coord_cartesian(clip = \"off\")"
  },
  {
    "objectID": "basics/plot-composer-basics.html",
    "href": "basics/plot-composer-basics.html",
    "title": "Plot Composer - Basics",
    "section": "",
    "text": "Plot Composer - Basics\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\np1 &lt;- ggplot(mtcars) +\n    geom_point(aes(mpg, disp)) +\n    ggtitle(\"Plot 1\")\n\np2 &lt;- ggplot(mtcars) +\n    geom_boxplot(aes(gear, disp, group = gear)) +\n    ggtitle(\"Plot 2\")\n\np3 &lt;- ggplot(mtcars) +\n    geom_point(aes(hp, wt, colour = mpg)) +\n    ggtitle(\"Plot 3\")\n\np4 &lt;- ggplot(mtcars) +\n    geom_bar(aes(gear)) +\n    facet_wrap(~cyl) +\n    ggtitle(\"Plot 4\")\n\nCombine plots directly:\n\nalign_plots(p1, p2)\n\n\n\n\n\n\n\nBy row:\n\nalign_plots(p1, p2, ncol = 1)\n\n\n\n\n\n\n\nAlign a list of plots:\n\nalign_plots(!!!list(p1, p2, p3))\n\n\n\n\n\n\n\nSet different width for plots:\n\nalign_plots(p1, p2, widths = c(2, 1))\n\n\n\n\n\n\n\nWorks for multiple plots:\n\nalign_plots(p1, p2, p3, p4, ncol = 2, widths = c(2, 1))\n\n\n\n\n\n\n\nAdd empty plot:\n\nalign_plots(p1, NULL, p2)\n\n\n\n\n\n\n\nMore see Data-Free Composition of ggalign tutorial book."
  },
  {
    "objectID": "basics/heatmap.html",
    "href": "basics/heatmap.html",
    "title": "Heatmap",
    "section": "",
    "text": "library(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\nset.seed(123)\n# Prepare heatmap matrix\nmat &lt;- matrix(\n    rnorm(90, mean = 0, sd = 2),\n    nrow = 9, ncol = 10,\n    dimnames = list(paste0(\"G\", 1:9), paste0(\"S\", 1:10))\n)\n\n\n\nggheatmap(mat)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nGroup columns by a categorical variable (e.g., randomly assigned groups “a” to “d”):\n\nggheatmap(mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(mat), replace = TRUE))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nGroup columns by k-means clusters (3 clusters in this example):\n\nggheatmap(mat) +\n    anno_top() +\n    align_kmeans(3)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nOrder the rows based on their mean values to highlight overall expression trends:\n\nggheatmap(mat) +\n    anno_left() +\n    align_order(rowMeans)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nAdd a dendrogram on top with branches colored and annotated, showing 3 clusters:\n\nggheatmap(mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    geom_point(aes(color = branch, y = y)) +\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nAdd colored annotation bars on top of the heatmap, matching cluster assignment:\n\nggheatmap(mat) +\n    anno_top(size = unit(1, \"cm\")) +\n    align_kmeans(centers = 3L) +\n    ggalign(data = NULL) +\n    geom_tile(aes(y = 1L, fill = .panel, color = .panel)) +\n    theme_no_axes(\"y\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    anno_right(size = 0.3) +\n    align_dendro() +\n    anno_left(size = 0.3) +\n    ggalign(rowSums) +\n    geom_bar(aes(x = value, y = .y, fill = value),\n        orientation = \"y\", stat = \"identity\"\n    ) +\n    scale_fill_viridis_c(option = \"A\")\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/heatmap.html#basic-heatmap",
    "href": "basics/heatmap.html#basic-heatmap",
    "title": "Heatmap",
    "section": "",
    "text": "ggheatmap(mat)\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/heatmap.html#group-heatmap-by-sample-groups",
    "href": "basics/heatmap.html#group-heatmap-by-sample-groups",
    "title": "Heatmap",
    "section": "",
    "text": "Group columns by a categorical variable (e.g., randomly assigned groups “a” to “d”):\n\nggheatmap(mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(mat), replace = TRUE))\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/heatmap.html#group-heatmap-by-k-means-clustering",
    "href": "basics/heatmap.html#group-heatmap-by-k-means-clustering",
    "title": "Heatmap",
    "section": "",
    "text": "Group columns by k-means clusters (3 clusters in this example):\n\nggheatmap(mat) +\n    anno_top() +\n    align_kmeans(3)\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/heatmap.html#order-rows-by-mean-values",
    "href": "basics/heatmap.html#order-rows-by-mean-values",
    "title": "Heatmap",
    "section": "",
    "text": "Order the rows based on their mean values to highlight overall expression trends:\n\nggheatmap(mat) +\n    anno_left() +\n    align_order(rowMeans)\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/heatmap.html#add-dendrogram-with-branch-coloring",
    "href": "basics/heatmap.html#add-dendrogram-with-branch-coloring",
    "title": "Heatmap",
    "section": "",
    "text": "Add a dendrogram on top with branches colored and annotated, showing 3 clusters:\n\nggheatmap(mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    geom_point(aes(color = branch, y = y)) +\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/heatmap.html#annotate-top-with-color-bars",
    "href": "basics/heatmap.html#annotate-top-with-color-bars",
    "title": "Heatmap",
    "section": "",
    "text": "Add colored annotation bars on top of the heatmap, matching cluster assignment:\n\nggheatmap(mat) +\n    anno_top(size = unit(1, \"cm\")) +\n    align_kmeans(centers = 3L) +\n    ggalign(data = NULL) +\n    geom_tile(aes(y = 1L, fill = .panel, color = .panel)) +\n    theme_no_axes(\"y\")\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/heatmap.html#annotate-on-both-left-and-right-sides",
    "href": "basics/heatmap.html#annotate-on-both-left-and-right-sides",
    "title": "Heatmap",
    "section": "",
    "text": "ggheatmap(mat) +\n    anno_right(size = 0.3) +\n    align_dendro() +\n    anno_left(size = 0.3) +\n    ggalign(rowSums) +\n    geom_bar(aes(x = value, y = .y, fill = value),\n        orientation = \"y\", stat = \"identity\"\n    ) +\n    scale_fill_viridis_c(option = \"A\")\n#&gt; → heatmap built with `geom_tile()`"
  },
  {
    "objectID": "basics/stack-bar.html",
    "href": "basics/stack-bar.html",
    "title": "Stacked bar",
    "section": "",
    "text": "Stacked bar\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n#&gt; \n#&gt; Attaching package: 'ggalign'\n#&gt; The following object is masked from 'package:ggplot2':\n#&gt; \n#&gt;     element_polygon\n\n\n# Simulate data (same seed and structure)\nset.seed(0)\ndata &lt;- matrix(sample(1:99, 50, replace = TRUE), nrow = 10)\nrownames(data) &lt;- paste0(\"V\", 1:10)\ncolnames(data) &lt;- letters[1:5]\ncategory &lt;- rep(c(1, 1, 2, 2, 4), each = 2)\n\n\nstack_discretev(data) +\n\n    # add bar for total\n    ggalign(rowSums, size = 0.1) +\n    geom_tile(aes(y = 1, fill = value)) +\n    scale_fill_viridis_c(name = \"Total\") +\n\n    # add bar for catogery\n    ggalign(factor(category), size = 0.1) +\n    geom_tile(aes(y = 1, fill = value)) +\n    scale_fill_brewer(palette = \"Set2\", name = \"Category\") -\n    scale_y_continuous(breaks = NULL, name = NULL) +\n\n    ggalign() +\n    geom_bar(aes(y = value, fill = .column_names),\n        stat = \"identity\", position = position_fill()\n    ) +\n    scale_fill_brewer(palette = \"Dark2\", name = \"Stacked Bar\")"
  }
]